<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gegravity.MonteCarloGE API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gegravity.MonteCarloGE</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__Author__ = &#34;Peter Herman&#34;
__Project__ = &#34;gegravity&#34;
__Created__ = &#34;May 05, 2020&#34;
__Description__ = &#39;&#39;&#39;A method for Generating Monte Carlo GE gegravity using the distributions of parameter estimates from 
the empirical model &#39;&#39;&#39;
__all__ = [&#39;MonteCarloGE&#39;]

import numpy as np
import pandas as pd
from pandas import DataFrame
from gme.estimate.EstimationModel import EstimationModel
from gegravity.OneSectorGE import OneSectorGE, CostCoeffs, _GEMetaData
from scipy.stats import multivariate_normal
from statsmodels.genmod.generalized_linear_model import GLMResultsWrapper
from typing import List

class MonteCarloGE(object):
    def __init__(self,
                 estimation_model: EstimationModel,
                 year:str,
                 trials: int,
                 expend_var_name: str,
                 output_var_name: str,
                 sigma: float,
                 reference_importer: str,
                 cost_variables: list,
                 mc_variables: list = None,
                 results_key: str = &#39;all&#39;,
                 seed: int = 0):
        &#39;&#39;&#39;
        Define a Monte Carlo GE model.
        Args:
            estimation_model (gme.EstimationModel): A GME EstimationModel that must have been estimated with the option
                full_results = True (MonteCarlo simulation requires additional info from estimation compared to
                OneSectorGE).
            year (str): The year to be used for the baseline model. Works best if estimation_model year column has been
                cast as string.
            trials (int): The number of trial simulations to conduct.
            expend_var_name (str): Column name of variable containing expenditure data in estimation_model.
            output_var_name (str): Column name of variable containing output data in estimation_model.
            sigma (float): Elasticity of substitution.
            reference_importer (str): Identifier for the country to be used as the reference importer (inward
                multilateral resistance normalized to 1 and other multilateral resistances solved relative to it).
            cost_variables (List[str]): (optional) A list of variables to use to compute bilateral trade costs. By
                default, all included non-fixed effect variables are used.
            mc_variables (List[str]): (optional) A subset of the cost_variables to randomly sample in the Monte Carlo
                experiment. Coefficients for the variables in this list are randomly drawn based on their estimated mean
                 and variance/covariance. Those excluded use their gravity estimated values only. By default, the model
                uses all cost variables (or those supplied to cost_variables argument) are
            results_key (str): (optional) If using parameter estimates from estimation_model, this is the key (i.e.
                sector) corresponding to the estimates to be used. For single sector estimations (sector_by_sector =
                False in GME model), this key is &#39;all&#39;, which is the default.
            seed (int): (optional) The seed to use for the random draws of cost coefficients in order to provide
                unchanging, consistent draws across runs. By default, the seed is randomly determined each time the
                model is constructed.

        Attributes:
            baseline_data (pandas.DataFrame): Baseline data supplied to model in gme.EstimationModel.
            coeff_sample (Pandas.DataFrame): The randomly drawn sample of cost coefficients for each cost variable. Each
                column corresponds to a different trial.
            main_coeffs (pandas.Series): The main coefficient estimates for the cost varaibles supplied to the model.
            main_stderrs (pandas.Series): The standard errors for the main cost coefficients.
            trials (int): The number of trial simulations of the model.
            sample_stats (pandas.DataFrame): A dataframe depicting both the initially supplied estimate values for each
                cost variable (&#39;beta_estimate&#39; and &#39;stderr_estimate&#39;) as well as descriptive statistics for the randomly
                drawn values across all trials.
            sigma (int): The elasticity of substitution parameter value.
            ---
            **Attributes containing results populated after MonteCarloGE.run_trials()**:\n\n
            aggregate_trade_results (Pandas.DataFrame): Aggregate trade results summarized across all trials. See
                OneSectorGE ResultsLabels for description of results.
            bilateral_costs (Pandas.DataFrame): Baseline and counterfactual bilateral trade costs summarized across all
                trials. See OneSectorGE ResultsLabels for description of results.
            bilateral_trade_results (Pandas.DataFrame): Bilateral trade results summarized across all trials.
                See OneSectorGE ResultsLabels for description of results.
            country_mr_terms (Pandas.DataFrame): Baseline and experiment multilateral resistance terms summarized
                across all trials. See OneSectorGE ResultsLabels for description of results.
            country_results (Pandas.DataFrame): The main country level results summarized across
                all trials. See OneSectorGE ResultsLabels for description of results.
            factory_gate_prices (Pandas.DataFrame): Factory gate prices summarized across all trials. See OneSectorGE
                ResultsLabels for description of results.
            num_failed_trials (int): The number of trials for which the model failed to solve.
            outputs_expenditures (Pandas.DataFrame): Baseline and experiment output and expenditure values summarized
                across all trials. See OneSectorGE ResultsLabels for description of results.
            solver_diagnostics (dict): A dictionary containing diagnostic information for each individual trial. The
                solver diagnostics for each trial correspond to the three solution routines: baseline
                multilateral resistances, conditional multilateral resistances (partial equilibrium counterfactual
                effects) and the full GE model. See the diagnostic info from scipy.optimize.root for more details.
            ---
            **Additional results populated if MonteCarloGE.run_trials(all_results=True)**\n\n
            all_aggregate_trade_results (Pandas.DataFrame): All aggregate trade results for each individual trial.
                Columns are multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels
                for description of results.
            all_bilateral_costs (Pandas.DataFrame): Bilateral trade costs for each individual trial. Columns are
                multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels for description of
                results.
            all_bilateral_trade_results (Pandas.DataFrame): Bilateral trade results for all individual trials.
                Columns are multi-indexed by the trial number and type of result.
                See OneSectorGE ResultsLabels for description of results.
            all_country_mr_terms (Pandas.DataFrame): All baseline and experiment multilateral resistance terms for each
                individual trial. Columns are multi-indexed by the trial number and type of result. See OneSectorGE
                ResultsLabels for description of results.
            all_country_results (Pandas.DataFrame): Main results for all individual trials.
                Columns are multi-indexed by the trial number and type of result.
                See OneSectorGE ResultsLabels for description of results.
            all_factory_gate_prices (Pandas.DataFrame): Factory gate prices for each individual trial. Columns are
                multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels for description of
                results.
            all_outputs_expenditures (Pandas.DataFrame): Baseline and experiment output and expenditure values for each
                individual trial. Columns are multi-indexed by the trial number and type of result. See OneSectorGE
                ResultsLabels for description of results.
        &#39;&#39;&#39;


        # Store some inputs in model object
        self._estimation_model = estimation_model
        self.meta_data = _GEMetaData(estimation_model.estimation_data._meta_data, expend_var_name, output_var_name)
        self._year = str(year)
        self.sigma = sigma
        self._reference_importer = reference_importer
        self._cost_variables = cost_variables
        if mc_variables is None:
            self._mc_variables = self._cost_variables
        else:
            self._mc_variables = mc_variables
        if seed is None:
            self._seed = np.random.randint(0,10000)
        else:
            self._seed = seed
        self._results_key = results_key

        # Define Parameter values
        self.main_coeffs = self._estimation_model.results_dict[self._results_key].params
        self.main_stderrs = self._estimation_model.results_dict[self._results_key].bse
        self.trials = trials

        # Generate Sampling Distribution
        self.coeff_sample = self._draw_mc_trade_costs()

        ##
        # Define Results attributes
        ##
        self.num_failed_trials = None
        self.all_country_results = None
        self.country_results = None
        self.all_country_mr_terms = None
        self.country_mr_terms = None
        self.all_outputs_expenditures = None
        self.outputs_expenditures = None
        self.all_factory_gate_prices = None
        self.factory_gate_prices = None
        self.all_aggregate_trade_results = None
        self.aggregate_trade_results = None
        self.all_bilateral_trade_results = None
        self.bilateral_trade_results = None
        self.all_bilateral_costs = None
        self.bilateral_costs = None
        self.solver_diagnostics = None


        # prep baseline data
        _baseline_data = self._estimation_model.estimation_data.data_frame.copy()
        _baseline_data[self.meta_data.year_var_name] = _baseline_data[self.meta_data.year_var_name].astype(str)
        self.baseline_data = _baseline_data.loc[_baseline_data[self.meta_data.year_var_name] == self._year, :].copy()
        if self.baseline_data.shape[0] == 0:
            raise ValueError(&#34;There are no observations corresponding to the supplied &#39;year&#39;&#34;)

        # Create summary of sample distrbution
        sample_stats = self.coeff_sample.copy()
        sample_stats.set_index(&#39;index&#39;, inplace= True)
        sample_stats = sample_stats.T.describe().T

        # sample_stats = self.coeff_sample.T.describe().T
        new_col_names = [&#39;sample_{}&#39;.format(col) for col in sample_stats]
        sample_stats.columns = new_col_names
        main_cost_ests = pd.DataFrame({&#39;beta_estimate&#39;: self.main_coeffs[self._mc_variables],
                                       &#39;stderr_estimate&#39;: self.main_stderrs[self._mc_variables]})
        self.sample_stats = pd.concat([main_cost_ests, sample_stats], axis=1)

    def _draw_mc_trade_costs(self):
        &#39;&#39;&#39;
        Draw coefficient values from multivariate normal distribution. For Poisson MLE,
        B-hat ~ Normal(B, (X&#39;WX)^{-1}) where (X&#39;WX)^{-1} is the covariance matrix. See An Introduction to Generalized
        Linear Models (2nd Ed) Annette J. Dobson, Chapman &amp; Hall/CRC, Boca Raton Florida, Section 5.4.

        Returns: A dataframe of random draws of coefficients. Rows are cost variables from self._mc_variables, columns
            are different draws with the exception of a column with corresponding cost variable names (&#39;index&#39;)
        &#39;&#39;&#39;
        # Get results and check that all needed info is available (i.e. covariance matrix in estimation model)
        est_results = self._estimation_model.results_dict[self._results_key]
        if not isinstance(est_results,GLMResultsWrapper):
            raise TypeError(&#39;MonteCarloGE requires that gme.EstimationModel be estimated with option full_results=True&#39;)
        betas = est_results.params.values

        cov = self._estimation_model.results_dict[self._results_key].cov_params()
        distribution_alt = multivariate_normal(betas, cov, seed=self._seed)
        draws = list()
        for i in range(self.trials):
            draws.append(pd.Series(distribution_alt.rvs()))
        all_draws = pd.concat(draws, axis=1)
        all_draws.index = est_results.params.index
        all_draws = all_draws.loc[self._mc_variables,:]
        return all_draws.reset_index()


    def run_trials(self,
                   experiment_data:pd.DataFrame,
                   omr_rescale: float = 1,
                   imr_rescale: float = 1,
                   mr_method: str = &#39;hybr&#39;,
                   mr_max_iter: int = 1400,
                   mr_tolerance: float = 1e-8,
                   ge_method:str = &#39;hybr&#39;,
                   ge_tolerance: float = 1e-8,
                   ge_max_iter: int = 1000,
                   quiet: bool = False,
                   result_stats:list = [&#39;mean&#39;, &#39;std&#39;, &#39;sem&#39;],
                   all_results:bool = False):
        &#39;&#39;&#39;
        Conduct Monte Carlo Simulation of OneSectorGE gravity model.
        Args:
            experiment_data (pandas.DataFrame): A dataframe containing the counterfactual trade-cost data to use for the
                experiment. The best approach for creating this data is to copy the baseline data
                (MonteCarloGE.baseline_data.copy()) and modify columns/rows to reflect desired counterfactual experiment.
            omr_rescale (int): (optional) This value rescales the OMR values to assist in convergence. Often, OMR values
                are orders of magnitude different than IMR values, which can make convergence difficult. Scaling by a
                different order of magnitude can help. Values should be of the form 10^n. By default, this value is 1
                (10^0). However, users should be careful with this choice as results, even when convergent, may not be
                fully robust to any selection. The method OneSectorGE.check_omr_rescale() can help identify and compare
                feasible values for a given model.
            imr_rescale (int): (optional) This value rescales the IMR values to potentially aid in conversion. However,
                because the IMR for the reference importer is normalized to one, it is unlikely that there will be because
                because changing the default value, which is 1.
            mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
                experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
                value is &#39;hybr&#39;. (See also OneSectorGE.build_baseline())
            mr_max_iter (int): This parameter sets the maximum limit on the number of iterations conducted
                by the solver used to solve for MR terms. The default value is 1400.
                (See also OneSectorGE.build_baseline())
            mr_tolerance (float): This parameter sets the convergence tolerance level for the solver used to
                solve for MR terms. The default value is 1e-8. (See also OneSectorGE.build_baseline())
            ge_method (str): The solver method to use for the full GE non-linear solver. See scipy.root()
                documentation for option. Default is &#39;hybr&#39;.
            ge_tolerance (float): The tolerance for determining if the GE system of equations is solved.
                Default is 1e-8.
            ge_max_iter (int): The maximum number of iterations allowed for the full GE nonlinear solver.
                Default is 1000.
            quiet (bool): If True, suppress console printouts detailing the solver success/failures of each trial.
                Default is False.
            result_stats (list): A list of functions to compute in order to summarize the results across trials. The
                default is [&#39;mean&#39;, &#39;std&#39;, &#39;sem&#39;], which computes the mean, standard deviation, and standard mean error
                of the results, respectively. The model should accept any function that can be used with the
                pandas.DataFrame.agg() function.
            all_results (bool): If true, MonteCarloGE attributes containing individual results for all trials are
                populated. Default is False to reduce memory use.

        Returns:
            None: No return but populates many results attributes of the MonteCarloGE model.

        &#39;&#39;&#39;
        models = list()
        num_failed_iterations = 0
        for trial in range(self.trials):
            print(&#34;\n* Simulating trial {} *&#34;.format(trial))
            param_values = CostCoeffs(self.coeff_sample, coeff_col=trial, identifier_col=&#39;index&#39;)
            try:
                trial_model = OneSectorGE(self._estimation_model,
                                          year=self._year,
                                          reference_importer=self._reference_importer,
                                          expend_var_name=self.meta_data.expend_var_name,
                                          output_var_name=self.meta_data.output_var_name,
                                          sigma=self.sigma,
                                          results_key=self._results_key,
                                          cost_variables=self._cost_variables,
                                          cost_coeff_values=param_values,
                                          # approach = approach,
                                          quiet = quiet)
                trial_model.build_baseline(omr_rescale=omr_rescale,
                                           imr_rescale=imr_rescale,
                                           mr_method=mr_method,
                                           mr_max_iter=mr_max_iter,
                                           mr_tolerance=mr_tolerance)
                trial_model.define_experiment(experiment_data)
                trial_model.simulate(ge_method=ge_method,
                                     ge_tolerance=ge_tolerance,
                                     ge_max_iter=ge_max_iter)
                models.append(trial_model)
            except:
                print(&#34;Failed to solve model.\n&#34;)
                num_failed_iterations+=1

        # Get results labels from one of the OneSectorGE gegravity
        self.labels = models[0].labels
        self.num_failed_trials = num_failed_iterations
        self.all_country_results, self.country_results = self._compile_results(models, &#39;country_results&#39;, result_stats, all_results)
        self.all_country_mr_terms, self.country_mr_terms = self._compile_results(models, &#39;mr_terms&#39;, result_stats, all_results)
        self.all_outputs_expenditures, self.outputs_expenditures = self._compile_results(models, &#39;outputs_expenditures&#39;, result_stats, all_results)
        self.all_factory_gate_prices, self.factory_gate_prices = self._compile_results(models, &#39;factory_gate_prices&#39;, result_stats, all_results)
        self.all_aggregate_trade_results, self.aggregate_trade_results = self._compile_results(models, &#39;aggregate_trade_results&#39;, result_stats, all_results)
        self.all_bilateral_trade_results, self.bilateral_trade_results = self._compile_results(models, &#39;bilateral_trade&#39;, result_stats, all_results)
        self.all_bilateral_costs, self.bilateral_costs = self._compile_results(models, &#39;bilateral_costs&#39;, result_stats, all_results)
        self._compile_diagnostics(models)
        # ToDo: build some method for confidence intervals from Anderson Yotov (2016)


    def _compile_results(self, models, result_type, result_stats, all_results):
        &#39;&#39;&#39;
        Compile results across all trials.
        :param models: (List[OneSectorGE]) A list of solved OneSectorGE gegravity.
        :param result_type: (str) Type of results to compile. Function works with:
            &#39;country_results&#39; - compiles results from OneSectorGE.country_mr_results
            &#39;mr_terms&#39; - compiles results from OneSectorGE.country_mr_terms
            &#39;output_expenditures&#39; - compiles results from OneSectorGE.output_expenditures
            &#39;factory_gate_prices - compiles results from OneSectorGE.factory_gate_prices
            &#39;aggregate_trade_results&#39; - compiles results from OneSectorGE.aggregate_trade_results
            &#39;bilateral_trade&#39; - complies results from OneSectorGE.bilateral_trade_results
            &#39;bilateral_costs&#39; - compiles results from OneSectorGE.bilateral_costs
        :return:(pd.DataFrame, pd.DataFrame) Two dataframes. The first contains all results for each trial, with
            multiindex columns labeled (trial, result type). The second provides summary stats from all trials (mean,
            std, stderr)
        &#39;&#39;&#39;
        # Combine all results
        combined_results_list = list()
        for num, model in enumerate(models):
            if result_type == &#39;country_results&#39;:
                model_results = model.country_results.copy()
            if result_type == &#39;mr_terms&#39;:
                model_results = model.country_mr_terms
            if result_type == &#39;outputs_expenditures&#39;:
                model_results = model.outputs_expenditures
            if result_type == &#39;factory_gate_prices&#39;:
                model_results = model.factory_gate_prices
            if result_type == &#39;aggregate_trade_results&#39;:
                model_results = model.aggregate_trade_results
            if result_type == &#39;bilateral_trade&#39;:
                model_results = model.bilateral_trade_results
            if result_type == &#39;bilateral_costs&#39;:
                model_results = model.bilateral_costs

            # Label columns via multiindex with (trial #, result label)
            multi_columns = [(num,col) for col in model_results.columns]
            model_results.columns = pd.MultiIndex.from_tuples(multi_columns)
            combined_results_list.append(model_results)
        combined_results = pd.concat(combined_results_list, axis = 1)

        # Reshape trials to long format
        summary_results = combined_results.copy()
        if result_type in [&#39;bilateral_trade&#39;,&#39;bilateral_costs&#39;]:
            # Bilateral trade has a two-part index (exporter and importer) and must be treated separately.
            summary_results = summary_results.stack(0).reset_index(level=2)
            summary_results.rename(columns={&#39;level_2&#39;: &#39;trial&#39;}, inplace=True)
        else:
            summary_results = summary_results.stack(0).reset_index(level=1)
            summary_results.rename(columns={&#39;level_1&#39;: &#39;trial&#39;}, inplace=True)

        # Compute mean and std across trials
        agg_dict = dict()
        var_list = list(summary_results.columns)
        var_list.remove(&#39;trial&#39;)
        for var in var_list:
            agg_dict[var] = result_stats
        if result_type in [&#39;bilateral_trade&#39;,&#39;bilateral_costs&#39;]:
            summary_results = summary_results.groupby(level=[0, 1]).agg(agg_dict)
        else:
            summary_results = summary_results.groupby(level=0).agg(agg_dict)

        # Compute standard error for each result type
        # for col in summary_results.columns:
        #     if col[1] == &#39;std&#39;:
        #         summary_results[(col[0], &#39;stderr&#39;)] = summary_results[col] / (self.trials ** 0.5)
        if result_type in [&#39;bilateral_trade&#39;,&#39;bilateral_costs&#39;]:
            summary_results = summary_results.stack(level=1).reset_index(level=2)
            summary_results.rename(columns = {&#39;level_2&#39;:&#39;statistic&#39;},inplace = True)
        else:
            summary_results = summary_results.stack(level=1).reset_index(level=1)
            summary_results.rename(columns = {&#39;level_1&#39;:&#39;statistic&#39;},inplace = True)
        if all_results:
            return combined_results, summary_results
        else:
            return None, summary_results

    def _compile_diagnostics(self, models):
        &#39;&#39;&#39;
        Compiles the diagnostics from each trial into a single dictionary, indexed by the trial number.
        Args:
            models: the list of OneSectorGE gegravity associated with each trial

        Returns: None, Populates the attribute self.solver_daignostics

        &#39;&#39;&#39;
        combined_diagnostics = dict()
        for trial in range(self.trials):
            combined_diagnostics[trial] = models[trial].solver_diagnostics
        self.solver_diagnostics = combined_diagnostics

    def export_results(self, directory:str = None, name:str = &#39;&#39;,
                       country_names:DataFrame = None, all_results = False):
        &#39;&#39;&#39;
        Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral results,
        and (3) solver diagnostics.
        Args:
            directory (str): (optional) Directory in which to write results files. If no directory is supplied,
                three compiled dataframes are returned as a tuple in the order (Country-level results, bilateral
                results, solver diagnostics).
            name (str): (optional) Name of the simulation to prefix to the result file names.
            include_levels (bool): (optional) If True, includes additional columns reflecting the simulated changes in
                levels based on observed trade flows (rather than modeled trade flows). Values are those from the
                method calculate_levels.
            country_names (pandas.DataFrame): (optional) Adds alternative identifiers such as names to the returned
                results tables. The supplied DataFrame should include exactly two columns. The first column must be
                the country identifiers used in the model. The second column must be the alternative identifiers to
                add.

        Returns:
            None or Tuple[DataFrame, DataFrame, DataFrame]: If a directory argument is supplied, the method returns
                nothing and writes three .csv files instead. If no directory is supplied, it returns a tuple of
                DataFrames.

        Examples:


        &#39;&#39;&#39;

        importer_col = self.meta_data.imp_var_name
        exporter_col = self.meta_data.exp_var_name

        country_result_set = [self.country_results, self.factory_gate_prices, self.aggregate_trade_results,
                              self.outputs_expenditures, self.country_mr_terms]
        country_results = pd.concat(country_result_set, axis = 1)
        # Order and select columns for inclusion, drop duplicates.
        country_results_cols = country_results.columns
        labs = self.labels
        # Country results to include
        results_cols = [&#39;statistic&#39;] + self.labels.country_level_labels
        included_columns = [col for col in results_cols if col in country_results_cols]
        country_results = country_results[included_columns]
        country_results = country_results.loc[:, ~country_results.columns.duplicated()]

        bilateral_results = self.bilateral_trade_results.reset_index()

        if country_names is not None:
            if country_names.shape[1]!=2:
                raise ValueError(&#34;country_names should have exactly 2 columns, not {}&#34;.format(country_names.shape[1]))
            code_col = country_names.columns[0]
            name_col = country_names.columns[1]
            country_names.set_index(code_col, inplace = True, drop = True)
            country_results = country_names.merge(country_results, how = &#39;right&#39;, left_index = True, right_index=True)

            # Add names to bilateral data
            for side in [exporter_col, importer_col]:
                side_names = country_names.copy()
                side_names.reset_index(inplace = True)
                side_names.rename(columns = {code_col:side, name_col:&#34;{} {}&#34;.format(side,name_col)}, inplace = True)
                bilateral_results = bilateral_results.merge(side_names, how = &#39;left&#39;, on = side)

        # Create Dataframe with Diagnostic results
        column_list = list()
        diagnostics = self.solver_diagnostics
        for trial_num, trial in diagnostics.items():
            for results_type, results in trial.items():
                for key, value in results.items():
                    # Single Entry fields must be converted to list before creating DataFrame
                    if key in [&#39;success&#39;, &#39;status&#39;, &#39;nfev&#39;, &#39;message&#39;]:
                        frame = pd.DataFrame({(&#34;trial_{}&#34;.format(trial_num), results_type, key): [value]})
                        column_list.append(frame)
                    # Vector-like fields Can be used as is. Several available fields are not included: &#39;fjac&#39;,&#39;r&#39;, and &#39;qtf&#39;
                    elif key in [&#39;x&#39;, &#39;fun&#39;]:
                        frame = pd.DataFrame({(&#34;trial_{}&#34;.format(trial_num), results_type, key): value})
                        column_list.append(frame)
        diag_frame = pd.concat(column_list, axis=1)
        diag_frame = diag_frame.fillna(&#39;&#39;)

        if directory is not None:
            country_results.to_csv(&#34;{}/{}_country_results.csv&#34;.format(directory, name))
            bilateral_results.to_csv(&#34;{}/{}_bilateral_results.csv&#34;.format(directory, name), index=False)
            diag_frame.to_csv(&#34;{}/{}_solver_diagnostics.csv&#34;.format(directory, name), index=False)
        else:
            return country_results, bilateral_results, diag_frame</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gegravity.MonteCarloGE.MonteCarloGE"><code class="flex name class">
<span>class <span class="ident">MonteCarloGE</span></span>
<span>(</span><span>estimation_model: gme.estimate.EstimationModel.EstimationModel, year: str, trials: int, expend_var_name: str, output_var_name: str, sigma: float, reference_importer: str, cost_variables: list, mc_variables: list = None, results_key: str = 'all', seed: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a Monte Carlo GE model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>estimation_model</code></strong> :&ensp;<code>gme.EstimationModel</code></dt>
<dd>A GME EstimationModel that must have been estimated with the option
full_results = True (MonteCarlo simulation requires additional info from estimation compared to
OneSectorGE).</dd>
<dt><strong><code>year</code></strong> :&ensp;<code>str</code></dt>
<dd>The year to be used for the baseline model. Works best if estimation_model year column has been
cast as string.</dd>
<dt><strong><code>trials</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of trial simulations to conduct.</dd>
<dt><strong><code>expend_var_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Column name of variable containing expenditure data in estimation_model.</dd>
<dt><strong><code>output_var_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Column name of variable containing output data in estimation_model.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Elasticity of substitution.</dd>
<dt><strong><code>reference_importer</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the country to be used as the reference importer (inward
multilateral resistance normalized to 1 and other multilateral resistances solved relative to it).</dd>
<dt><strong><code>cost_variables</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>(optional) A list of variables to use to compute bilateral trade costs. By
default, all included non-fixed effect variables are used.</dd>
<dt><strong><code>mc_variables</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>(optional) A subset of the cost_variables to randomly sample in the Monte Carlo
experiment. Coefficients for the variables in this list are randomly drawn based on their estimated mean
and variance/covariance. Those excluded use their gravity estimated values only. By default, the model
uses all cost variables (or those supplied to cost_variables argument) are</dd>
<dt><strong><code>results_key</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) If using parameter estimates from estimation_model, this is the key (i.e.
sector) corresponding to the estimates to be used. For single sector estimations (sector_by_sector =
False in GME model), this key is 'all', which is the default.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional) The seed to use for the random draws of cost coefficients in order to provide
unchanging, consistent draws across runs. By default, the seed is randomly determined each time the
model is constructed.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>baseline_data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Baseline data supplied to model in gme.EstimationModel.</dd>
<dt><strong><code>coeff_sample</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>The randomly drawn sample of cost coefficients for each cost variable. Each
column corresponds to a different trial.</dd>
<dt><strong><code>main_coeffs</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>The main coefficient estimates for the cost varaibles supplied to the model.</dd>
<dt><strong><code>main_stderrs</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>The standard errors for the main cost coefficients.</dd>
<dt><strong><code>trials</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of trial simulations of the model.</dd>
<dt><strong><code>sample_stats</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>A dataframe depicting both the initially supplied estimate values for each
cost variable ('beta_estimate' and 'stderr_estimate') as well as descriptive statistics for the randomly
drawn values across all trials.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>int</code></dt>
<dd>The elasticity of substitution parameter value.</dd>
</dl>
<hr>
<p><strong>Attributes containing results populated after MonteCarloGE.run_trials()</strong>:</p>
<dl>
<dt><strong><code>aggregate_trade_results</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Aggregate trade results summarized across all trials. See
OneSectorGE ResultsLabels for description of results.</dd>
<dt><strong><code>bilateral_costs</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Baseline and counterfactual bilateral trade costs summarized across all
trials. See OneSectorGE ResultsLabels for description of results.</dd>
<dt><strong><code>bilateral_trade_results</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Bilateral trade results summarized across all trials.
See OneSectorGE ResultsLabels for description of results.</dd>
<dt><strong><code>country_mr_terms</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Baseline and experiment multilateral resistance terms summarized
across all trials. See OneSectorGE ResultsLabels for description of results.</dd>
<dt><strong><code>country_results</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>The main country level results summarized across
all trials. See OneSectorGE ResultsLabels for description of results.</dd>
<dt><strong><code>factory_gate_prices</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Factory gate prices summarized across all trials. See OneSectorGE
ResultsLabels for description of results.</dd>
<dt><strong><code>num_failed_trials</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of trials for which the model failed to solve.</dd>
<dt><strong><code>outputs_expenditures</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Baseline and experiment output and expenditure values summarized
across all trials. See OneSectorGE ResultsLabels for description of results.</dd>
<dt><strong><code>solver_diagnostics</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing diagnostic information for each individual trial. The
solver diagnostics for each trial correspond to the three solution routines: baseline
multilateral resistances, conditional multilateral resistances (partial equilibrium counterfactual
effects) and the full GE model. See the diagnostic info from scipy.optimize.root for more details.</dd>
</dl>
<hr>
<p><strong>Additional results populated if MonteCarloGE.run_trials(all_results=True)</strong></p>
<dl>
<dt><strong><code>all_aggregate_trade_results</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>All aggregate trade results for each individual trial.
Columns are multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels
for description of results.</dd>
<dt><strong><code>all_bilateral_costs</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Bilateral trade costs for each individual trial. Columns are
multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels for description of
results.</dd>
<dt><strong><code>all_bilateral_trade_results</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Bilateral trade results for all individual trials.
Columns are multi-indexed by the trial number and type of result.
See OneSectorGE ResultsLabels for description of results.</dd>
<dt><strong><code>all_country_mr_terms</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>All baseline and experiment multilateral resistance terms for each
individual trial. Columns are multi-indexed by the trial number and type of result. See OneSectorGE
ResultsLabels for description of results.</dd>
<dt><strong><code>all_country_results</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Main results for all individual trials.
Columns are multi-indexed by the trial number and type of result.
See OneSectorGE ResultsLabels for description of results.</dd>
<dt><strong><code>all_factory_gate_prices</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Factory gate prices for each individual trial. Columns are
multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels for description of
results.</dd>
<dt><strong><code>all_outputs_expenditures</code></strong> :&ensp;<code>Pandas.DataFrame</code></dt>
<dd>Baseline and experiment output and expenditure values for each
individual trial. Columns are multi-indexed by the trial number and type of result. See OneSectorGE
ResultsLabels for description of results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MonteCarloGE(object):
    def __init__(self,
                 estimation_model: EstimationModel,
                 year:str,
                 trials: int,
                 expend_var_name: str,
                 output_var_name: str,
                 sigma: float,
                 reference_importer: str,
                 cost_variables: list,
                 mc_variables: list = None,
                 results_key: str = &#39;all&#39;,
                 seed: int = 0):
        &#39;&#39;&#39;
        Define a Monte Carlo GE model.
        Args:
            estimation_model (gme.EstimationModel): A GME EstimationModel that must have been estimated with the option
                full_results = True (MonteCarlo simulation requires additional info from estimation compared to
                OneSectorGE).
            year (str): The year to be used for the baseline model. Works best if estimation_model year column has been
                cast as string.
            trials (int): The number of trial simulations to conduct.
            expend_var_name (str): Column name of variable containing expenditure data in estimation_model.
            output_var_name (str): Column name of variable containing output data in estimation_model.
            sigma (float): Elasticity of substitution.
            reference_importer (str): Identifier for the country to be used as the reference importer (inward
                multilateral resistance normalized to 1 and other multilateral resistances solved relative to it).
            cost_variables (List[str]): (optional) A list of variables to use to compute bilateral trade costs. By
                default, all included non-fixed effect variables are used.
            mc_variables (List[str]): (optional) A subset of the cost_variables to randomly sample in the Monte Carlo
                experiment. Coefficients for the variables in this list are randomly drawn based on their estimated mean
                 and variance/covariance. Those excluded use their gravity estimated values only. By default, the model
                uses all cost variables (or those supplied to cost_variables argument) are
            results_key (str): (optional) If using parameter estimates from estimation_model, this is the key (i.e.
                sector) corresponding to the estimates to be used. For single sector estimations (sector_by_sector =
                False in GME model), this key is &#39;all&#39;, which is the default.
            seed (int): (optional) The seed to use for the random draws of cost coefficients in order to provide
                unchanging, consistent draws across runs. By default, the seed is randomly determined each time the
                model is constructed.

        Attributes:
            baseline_data (pandas.DataFrame): Baseline data supplied to model in gme.EstimationModel.
            coeff_sample (Pandas.DataFrame): The randomly drawn sample of cost coefficients for each cost variable. Each
                column corresponds to a different trial.
            main_coeffs (pandas.Series): The main coefficient estimates for the cost varaibles supplied to the model.
            main_stderrs (pandas.Series): The standard errors for the main cost coefficients.
            trials (int): The number of trial simulations of the model.
            sample_stats (pandas.DataFrame): A dataframe depicting both the initially supplied estimate values for each
                cost variable (&#39;beta_estimate&#39; and &#39;stderr_estimate&#39;) as well as descriptive statistics for the randomly
                drawn values across all trials.
            sigma (int): The elasticity of substitution parameter value.
            ---
            **Attributes containing results populated after MonteCarloGE.run_trials()**:\n\n
            aggregate_trade_results (Pandas.DataFrame): Aggregate trade results summarized across all trials. See
                OneSectorGE ResultsLabels for description of results.
            bilateral_costs (Pandas.DataFrame): Baseline and counterfactual bilateral trade costs summarized across all
                trials. See OneSectorGE ResultsLabels for description of results.
            bilateral_trade_results (Pandas.DataFrame): Bilateral trade results summarized across all trials.
                See OneSectorGE ResultsLabels for description of results.
            country_mr_terms (Pandas.DataFrame): Baseline and experiment multilateral resistance terms summarized
                across all trials. See OneSectorGE ResultsLabels for description of results.
            country_results (Pandas.DataFrame): The main country level results summarized across
                all trials. See OneSectorGE ResultsLabels for description of results.
            factory_gate_prices (Pandas.DataFrame): Factory gate prices summarized across all trials. See OneSectorGE
                ResultsLabels for description of results.
            num_failed_trials (int): The number of trials for which the model failed to solve.
            outputs_expenditures (Pandas.DataFrame): Baseline and experiment output and expenditure values summarized
                across all trials. See OneSectorGE ResultsLabels for description of results.
            solver_diagnostics (dict): A dictionary containing diagnostic information for each individual trial. The
                solver diagnostics for each trial correspond to the three solution routines: baseline
                multilateral resistances, conditional multilateral resistances (partial equilibrium counterfactual
                effects) and the full GE model. See the diagnostic info from scipy.optimize.root for more details.
            ---
            **Additional results populated if MonteCarloGE.run_trials(all_results=True)**\n\n
            all_aggregate_trade_results (Pandas.DataFrame): All aggregate trade results for each individual trial.
                Columns are multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels
                for description of results.
            all_bilateral_costs (Pandas.DataFrame): Bilateral trade costs for each individual trial. Columns are
                multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels for description of
                results.
            all_bilateral_trade_results (Pandas.DataFrame): Bilateral trade results for all individual trials.
                Columns are multi-indexed by the trial number and type of result.
                See OneSectorGE ResultsLabels for description of results.
            all_country_mr_terms (Pandas.DataFrame): All baseline and experiment multilateral resistance terms for each
                individual trial. Columns are multi-indexed by the trial number and type of result. See OneSectorGE
                ResultsLabels for description of results.
            all_country_results (Pandas.DataFrame): Main results for all individual trials.
                Columns are multi-indexed by the trial number and type of result.
                See OneSectorGE ResultsLabels for description of results.
            all_factory_gate_prices (Pandas.DataFrame): Factory gate prices for each individual trial. Columns are
                multi-indexed by the trial number and type of result. See OneSectorGE ResultsLabels for description of
                results.
            all_outputs_expenditures (Pandas.DataFrame): Baseline and experiment output and expenditure values for each
                individual trial. Columns are multi-indexed by the trial number and type of result. See OneSectorGE
                ResultsLabels for description of results.
        &#39;&#39;&#39;


        # Store some inputs in model object
        self._estimation_model = estimation_model
        self.meta_data = _GEMetaData(estimation_model.estimation_data._meta_data, expend_var_name, output_var_name)
        self._year = str(year)
        self.sigma = sigma
        self._reference_importer = reference_importer
        self._cost_variables = cost_variables
        if mc_variables is None:
            self._mc_variables = self._cost_variables
        else:
            self._mc_variables = mc_variables
        if seed is None:
            self._seed = np.random.randint(0,10000)
        else:
            self._seed = seed
        self._results_key = results_key

        # Define Parameter values
        self.main_coeffs = self._estimation_model.results_dict[self._results_key].params
        self.main_stderrs = self._estimation_model.results_dict[self._results_key].bse
        self.trials = trials

        # Generate Sampling Distribution
        self.coeff_sample = self._draw_mc_trade_costs()

        ##
        # Define Results attributes
        ##
        self.num_failed_trials = None
        self.all_country_results = None
        self.country_results = None
        self.all_country_mr_terms = None
        self.country_mr_terms = None
        self.all_outputs_expenditures = None
        self.outputs_expenditures = None
        self.all_factory_gate_prices = None
        self.factory_gate_prices = None
        self.all_aggregate_trade_results = None
        self.aggregate_trade_results = None
        self.all_bilateral_trade_results = None
        self.bilateral_trade_results = None
        self.all_bilateral_costs = None
        self.bilateral_costs = None
        self.solver_diagnostics = None


        # prep baseline data
        _baseline_data = self._estimation_model.estimation_data.data_frame.copy()
        _baseline_data[self.meta_data.year_var_name] = _baseline_data[self.meta_data.year_var_name].astype(str)
        self.baseline_data = _baseline_data.loc[_baseline_data[self.meta_data.year_var_name] == self._year, :].copy()
        if self.baseline_data.shape[0] == 0:
            raise ValueError(&#34;There are no observations corresponding to the supplied &#39;year&#39;&#34;)

        # Create summary of sample distrbution
        sample_stats = self.coeff_sample.copy()
        sample_stats.set_index(&#39;index&#39;, inplace= True)
        sample_stats = sample_stats.T.describe().T

        # sample_stats = self.coeff_sample.T.describe().T
        new_col_names = [&#39;sample_{}&#39;.format(col) for col in sample_stats]
        sample_stats.columns = new_col_names
        main_cost_ests = pd.DataFrame({&#39;beta_estimate&#39;: self.main_coeffs[self._mc_variables],
                                       &#39;stderr_estimate&#39;: self.main_stderrs[self._mc_variables]})
        self.sample_stats = pd.concat([main_cost_ests, sample_stats], axis=1)

    def _draw_mc_trade_costs(self):
        &#39;&#39;&#39;
        Draw coefficient values from multivariate normal distribution. For Poisson MLE,
        B-hat ~ Normal(B, (X&#39;WX)^{-1}) where (X&#39;WX)^{-1} is the covariance matrix. See An Introduction to Generalized
        Linear Models (2nd Ed) Annette J. Dobson, Chapman &amp; Hall/CRC, Boca Raton Florida, Section 5.4.

        Returns: A dataframe of random draws of coefficients. Rows are cost variables from self._mc_variables, columns
            are different draws with the exception of a column with corresponding cost variable names (&#39;index&#39;)
        &#39;&#39;&#39;
        # Get results and check that all needed info is available (i.e. covariance matrix in estimation model)
        est_results = self._estimation_model.results_dict[self._results_key]
        if not isinstance(est_results,GLMResultsWrapper):
            raise TypeError(&#39;MonteCarloGE requires that gme.EstimationModel be estimated with option full_results=True&#39;)
        betas = est_results.params.values

        cov = self._estimation_model.results_dict[self._results_key].cov_params()
        distribution_alt = multivariate_normal(betas, cov, seed=self._seed)
        draws = list()
        for i in range(self.trials):
            draws.append(pd.Series(distribution_alt.rvs()))
        all_draws = pd.concat(draws, axis=1)
        all_draws.index = est_results.params.index
        all_draws = all_draws.loc[self._mc_variables,:]
        return all_draws.reset_index()


    def run_trials(self,
                   experiment_data:pd.DataFrame,
                   omr_rescale: float = 1,
                   imr_rescale: float = 1,
                   mr_method: str = &#39;hybr&#39;,
                   mr_max_iter: int = 1400,
                   mr_tolerance: float = 1e-8,
                   ge_method:str = &#39;hybr&#39;,
                   ge_tolerance: float = 1e-8,
                   ge_max_iter: int = 1000,
                   quiet: bool = False,
                   result_stats:list = [&#39;mean&#39;, &#39;std&#39;, &#39;sem&#39;],
                   all_results:bool = False):
        &#39;&#39;&#39;
        Conduct Monte Carlo Simulation of OneSectorGE gravity model.
        Args:
            experiment_data (pandas.DataFrame): A dataframe containing the counterfactual trade-cost data to use for the
                experiment. The best approach for creating this data is to copy the baseline data
                (MonteCarloGE.baseline_data.copy()) and modify columns/rows to reflect desired counterfactual experiment.
            omr_rescale (int): (optional) This value rescales the OMR values to assist in convergence. Often, OMR values
                are orders of magnitude different than IMR values, which can make convergence difficult. Scaling by a
                different order of magnitude can help. Values should be of the form 10^n. By default, this value is 1
                (10^0). However, users should be careful with this choice as results, even when convergent, may not be
                fully robust to any selection. The method OneSectorGE.check_omr_rescale() can help identify and compare
                feasible values for a given model.
            imr_rescale (int): (optional) This value rescales the IMR values to potentially aid in conversion. However,
                because the IMR for the reference importer is normalized to one, it is unlikely that there will be because
                because changing the default value, which is 1.
            mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
                experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
                value is &#39;hybr&#39;. (See also OneSectorGE.build_baseline())
            mr_max_iter (int): This parameter sets the maximum limit on the number of iterations conducted
                by the solver used to solve for MR terms. The default value is 1400.
                (See also OneSectorGE.build_baseline())
            mr_tolerance (float): This parameter sets the convergence tolerance level for the solver used to
                solve for MR terms. The default value is 1e-8. (See also OneSectorGE.build_baseline())
            ge_method (str): The solver method to use for the full GE non-linear solver. See scipy.root()
                documentation for option. Default is &#39;hybr&#39;.
            ge_tolerance (float): The tolerance for determining if the GE system of equations is solved.
                Default is 1e-8.
            ge_max_iter (int): The maximum number of iterations allowed for the full GE nonlinear solver.
                Default is 1000.
            quiet (bool): If True, suppress console printouts detailing the solver success/failures of each trial.
                Default is False.
            result_stats (list): A list of functions to compute in order to summarize the results across trials. The
                default is [&#39;mean&#39;, &#39;std&#39;, &#39;sem&#39;], which computes the mean, standard deviation, and standard mean error
                of the results, respectively. The model should accept any function that can be used with the
                pandas.DataFrame.agg() function.
            all_results (bool): If true, MonteCarloGE attributes containing individual results for all trials are
                populated. Default is False to reduce memory use.

        Returns:
            None: No return but populates many results attributes of the MonteCarloGE model.

        &#39;&#39;&#39;
        models = list()
        num_failed_iterations = 0
        for trial in range(self.trials):
            print(&#34;\n* Simulating trial {} *&#34;.format(trial))
            param_values = CostCoeffs(self.coeff_sample, coeff_col=trial, identifier_col=&#39;index&#39;)
            try:
                trial_model = OneSectorGE(self._estimation_model,
                                          year=self._year,
                                          reference_importer=self._reference_importer,
                                          expend_var_name=self.meta_data.expend_var_name,
                                          output_var_name=self.meta_data.output_var_name,
                                          sigma=self.sigma,
                                          results_key=self._results_key,
                                          cost_variables=self._cost_variables,
                                          cost_coeff_values=param_values,
                                          # approach = approach,
                                          quiet = quiet)
                trial_model.build_baseline(omr_rescale=omr_rescale,
                                           imr_rescale=imr_rescale,
                                           mr_method=mr_method,
                                           mr_max_iter=mr_max_iter,
                                           mr_tolerance=mr_tolerance)
                trial_model.define_experiment(experiment_data)
                trial_model.simulate(ge_method=ge_method,
                                     ge_tolerance=ge_tolerance,
                                     ge_max_iter=ge_max_iter)
                models.append(trial_model)
            except:
                print(&#34;Failed to solve model.\n&#34;)
                num_failed_iterations+=1

        # Get results labels from one of the OneSectorGE gegravity
        self.labels = models[0].labels
        self.num_failed_trials = num_failed_iterations
        self.all_country_results, self.country_results = self._compile_results(models, &#39;country_results&#39;, result_stats, all_results)
        self.all_country_mr_terms, self.country_mr_terms = self._compile_results(models, &#39;mr_terms&#39;, result_stats, all_results)
        self.all_outputs_expenditures, self.outputs_expenditures = self._compile_results(models, &#39;outputs_expenditures&#39;, result_stats, all_results)
        self.all_factory_gate_prices, self.factory_gate_prices = self._compile_results(models, &#39;factory_gate_prices&#39;, result_stats, all_results)
        self.all_aggregate_trade_results, self.aggregate_trade_results = self._compile_results(models, &#39;aggregate_trade_results&#39;, result_stats, all_results)
        self.all_bilateral_trade_results, self.bilateral_trade_results = self._compile_results(models, &#39;bilateral_trade&#39;, result_stats, all_results)
        self.all_bilateral_costs, self.bilateral_costs = self._compile_results(models, &#39;bilateral_costs&#39;, result_stats, all_results)
        self._compile_diagnostics(models)
        # ToDo: build some method for confidence intervals from Anderson Yotov (2016)


    def _compile_results(self, models, result_type, result_stats, all_results):
        &#39;&#39;&#39;
        Compile results across all trials.
        :param models: (List[OneSectorGE]) A list of solved OneSectorGE gegravity.
        :param result_type: (str) Type of results to compile. Function works with:
            &#39;country_results&#39; - compiles results from OneSectorGE.country_mr_results
            &#39;mr_terms&#39; - compiles results from OneSectorGE.country_mr_terms
            &#39;output_expenditures&#39; - compiles results from OneSectorGE.output_expenditures
            &#39;factory_gate_prices - compiles results from OneSectorGE.factory_gate_prices
            &#39;aggregate_trade_results&#39; - compiles results from OneSectorGE.aggregate_trade_results
            &#39;bilateral_trade&#39; - complies results from OneSectorGE.bilateral_trade_results
            &#39;bilateral_costs&#39; - compiles results from OneSectorGE.bilateral_costs
        :return:(pd.DataFrame, pd.DataFrame) Two dataframes. The first contains all results for each trial, with
            multiindex columns labeled (trial, result type). The second provides summary stats from all trials (mean,
            std, stderr)
        &#39;&#39;&#39;
        # Combine all results
        combined_results_list = list()
        for num, model in enumerate(models):
            if result_type == &#39;country_results&#39;:
                model_results = model.country_results.copy()
            if result_type == &#39;mr_terms&#39;:
                model_results = model.country_mr_terms
            if result_type == &#39;outputs_expenditures&#39;:
                model_results = model.outputs_expenditures
            if result_type == &#39;factory_gate_prices&#39;:
                model_results = model.factory_gate_prices
            if result_type == &#39;aggregate_trade_results&#39;:
                model_results = model.aggregate_trade_results
            if result_type == &#39;bilateral_trade&#39;:
                model_results = model.bilateral_trade_results
            if result_type == &#39;bilateral_costs&#39;:
                model_results = model.bilateral_costs

            # Label columns via multiindex with (trial #, result label)
            multi_columns = [(num,col) for col in model_results.columns]
            model_results.columns = pd.MultiIndex.from_tuples(multi_columns)
            combined_results_list.append(model_results)
        combined_results = pd.concat(combined_results_list, axis = 1)

        # Reshape trials to long format
        summary_results = combined_results.copy()
        if result_type in [&#39;bilateral_trade&#39;,&#39;bilateral_costs&#39;]:
            # Bilateral trade has a two-part index (exporter and importer) and must be treated separately.
            summary_results = summary_results.stack(0).reset_index(level=2)
            summary_results.rename(columns={&#39;level_2&#39;: &#39;trial&#39;}, inplace=True)
        else:
            summary_results = summary_results.stack(0).reset_index(level=1)
            summary_results.rename(columns={&#39;level_1&#39;: &#39;trial&#39;}, inplace=True)

        # Compute mean and std across trials
        agg_dict = dict()
        var_list = list(summary_results.columns)
        var_list.remove(&#39;trial&#39;)
        for var in var_list:
            agg_dict[var] = result_stats
        if result_type in [&#39;bilateral_trade&#39;,&#39;bilateral_costs&#39;]:
            summary_results = summary_results.groupby(level=[0, 1]).agg(agg_dict)
        else:
            summary_results = summary_results.groupby(level=0).agg(agg_dict)

        # Compute standard error for each result type
        # for col in summary_results.columns:
        #     if col[1] == &#39;std&#39;:
        #         summary_results[(col[0], &#39;stderr&#39;)] = summary_results[col] / (self.trials ** 0.5)
        if result_type in [&#39;bilateral_trade&#39;,&#39;bilateral_costs&#39;]:
            summary_results = summary_results.stack(level=1).reset_index(level=2)
            summary_results.rename(columns = {&#39;level_2&#39;:&#39;statistic&#39;},inplace = True)
        else:
            summary_results = summary_results.stack(level=1).reset_index(level=1)
            summary_results.rename(columns = {&#39;level_1&#39;:&#39;statistic&#39;},inplace = True)
        if all_results:
            return combined_results, summary_results
        else:
            return None, summary_results

    def _compile_diagnostics(self, models):
        &#39;&#39;&#39;
        Compiles the diagnostics from each trial into a single dictionary, indexed by the trial number.
        Args:
            models: the list of OneSectorGE gegravity associated with each trial

        Returns: None, Populates the attribute self.solver_daignostics

        &#39;&#39;&#39;
        combined_diagnostics = dict()
        for trial in range(self.trials):
            combined_diagnostics[trial] = models[trial].solver_diagnostics
        self.solver_diagnostics = combined_diagnostics

    def export_results(self, directory:str = None, name:str = &#39;&#39;,
                       country_names:DataFrame = None, all_results = False):
        &#39;&#39;&#39;
        Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral results,
        and (3) solver diagnostics.
        Args:
            directory (str): (optional) Directory in which to write results files. If no directory is supplied,
                three compiled dataframes are returned as a tuple in the order (Country-level results, bilateral
                results, solver diagnostics).
            name (str): (optional) Name of the simulation to prefix to the result file names.
            include_levels (bool): (optional) If True, includes additional columns reflecting the simulated changes in
                levels based on observed trade flows (rather than modeled trade flows). Values are those from the
                method calculate_levels.
            country_names (pandas.DataFrame): (optional) Adds alternative identifiers such as names to the returned
                results tables. The supplied DataFrame should include exactly two columns. The first column must be
                the country identifiers used in the model. The second column must be the alternative identifiers to
                add.

        Returns:
            None or Tuple[DataFrame, DataFrame, DataFrame]: If a directory argument is supplied, the method returns
                nothing and writes three .csv files instead. If no directory is supplied, it returns a tuple of
                DataFrames.

        Examples:


        &#39;&#39;&#39;

        importer_col = self.meta_data.imp_var_name
        exporter_col = self.meta_data.exp_var_name

        country_result_set = [self.country_results, self.factory_gate_prices, self.aggregate_trade_results,
                              self.outputs_expenditures, self.country_mr_terms]
        country_results = pd.concat(country_result_set, axis = 1)
        # Order and select columns for inclusion, drop duplicates.
        country_results_cols = country_results.columns
        labs = self.labels
        # Country results to include
        results_cols = [&#39;statistic&#39;] + self.labels.country_level_labels
        included_columns = [col for col in results_cols if col in country_results_cols]
        country_results = country_results[included_columns]
        country_results = country_results.loc[:, ~country_results.columns.duplicated()]

        bilateral_results = self.bilateral_trade_results.reset_index()

        if country_names is not None:
            if country_names.shape[1]!=2:
                raise ValueError(&#34;country_names should have exactly 2 columns, not {}&#34;.format(country_names.shape[1]))
            code_col = country_names.columns[0]
            name_col = country_names.columns[1]
            country_names.set_index(code_col, inplace = True, drop = True)
            country_results = country_names.merge(country_results, how = &#39;right&#39;, left_index = True, right_index=True)

            # Add names to bilateral data
            for side in [exporter_col, importer_col]:
                side_names = country_names.copy()
                side_names.reset_index(inplace = True)
                side_names.rename(columns = {code_col:side, name_col:&#34;{} {}&#34;.format(side,name_col)}, inplace = True)
                bilateral_results = bilateral_results.merge(side_names, how = &#39;left&#39;, on = side)

        # Create Dataframe with Diagnostic results
        column_list = list()
        diagnostics = self.solver_diagnostics
        for trial_num, trial in diagnostics.items():
            for results_type, results in trial.items():
                for key, value in results.items():
                    # Single Entry fields must be converted to list before creating DataFrame
                    if key in [&#39;success&#39;, &#39;status&#39;, &#39;nfev&#39;, &#39;message&#39;]:
                        frame = pd.DataFrame({(&#34;trial_{}&#34;.format(trial_num), results_type, key): [value]})
                        column_list.append(frame)
                    # Vector-like fields Can be used as is. Several available fields are not included: &#39;fjac&#39;,&#39;r&#39;, and &#39;qtf&#39;
                    elif key in [&#39;x&#39;, &#39;fun&#39;]:
                        frame = pd.DataFrame({(&#34;trial_{}&#34;.format(trial_num), results_type, key): value})
                        column_list.append(frame)
        diag_frame = pd.concat(column_list, axis=1)
        diag_frame = diag_frame.fillna(&#39;&#39;)

        if directory is not None:
            country_results.to_csv(&#34;{}/{}_country_results.csv&#34;.format(directory, name))
            bilateral_results.to_csv(&#34;{}/{}_bilateral_results.csv&#34;.format(directory, name), index=False)
            diag_frame.to_csv(&#34;{}/{}_solver_diagnostics.csv&#34;.format(directory, name), index=False)
        else:
            return country_results, bilateral_results, diag_frame</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gegravity.MonteCarloGE.MonteCarloGE.export_results"><code class="name flex">
<span>def <span class="ident">export_results</span></span>(<span>self, directory: str = None, name: str = '', country_names: pandas.core.frame.DataFrame = None, all_results=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral results,
and (3) solver diagnostics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) Directory in which to write results files. If no directory is supplied,
three compiled dataframes are returned as a tuple in the order (Country-level results, bilateral
results, solver diagnostics).</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) Name of the simulation to prefix to the result file names.</dd>
<dt><strong><code>include_levels</code></strong> :&ensp;<code>bool</code></dt>
<dd>(optional) If True, includes additional columns reflecting the simulated changes in
levels based on observed trade flows (rather than modeled trade flows). Values are those from the
method calculate_levels.</dd>
<dt><strong><code>country_names</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>(optional) Adds alternative identifiers such as names to the returned
results tables. The supplied DataFrame should include exactly two columns. The first column must be
the country identifiers used in the model. The second column must be the alternative identifiers to
add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code> or <code>Tuple[DataFrame, DataFrame, DataFrame]</code></dt>
<dd>If a directory argument is supplied, the method returns
nothing and writes three .csv files instead. If no directory is supplied, it returns a tuple of
DataFrames.</dd>
</dl>
<p>Examples:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_results(self, directory:str = None, name:str = &#39;&#39;,
                   country_names:DataFrame = None, all_results = False):
    &#39;&#39;&#39;
    Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral results,
    and (3) solver diagnostics.
    Args:
        directory (str): (optional) Directory in which to write results files. If no directory is supplied,
            three compiled dataframes are returned as a tuple in the order (Country-level results, bilateral
            results, solver diagnostics).
        name (str): (optional) Name of the simulation to prefix to the result file names.
        include_levels (bool): (optional) If True, includes additional columns reflecting the simulated changes in
            levels based on observed trade flows (rather than modeled trade flows). Values are those from the
            method calculate_levels.
        country_names (pandas.DataFrame): (optional) Adds alternative identifiers such as names to the returned
            results tables. The supplied DataFrame should include exactly two columns. The first column must be
            the country identifiers used in the model. The second column must be the alternative identifiers to
            add.

    Returns:
        None or Tuple[DataFrame, DataFrame, DataFrame]: If a directory argument is supplied, the method returns
            nothing and writes three .csv files instead. If no directory is supplied, it returns a tuple of
            DataFrames.

    Examples:


    &#39;&#39;&#39;

    importer_col = self.meta_data.imp_var_name
    exporter_col = self.meta_data.exp_var_name

    country_result_set = [self.country_results, self.factory_gate_prices, self.aggregate_trade_results,
                          self.outputs_expenditures, self.country_mr_terms]
    country_results = pd.concat(country_result_set, axis = 1)
    # Order and select columns for inclusion, drop duplicates.
    country_results_cols = country_results.columns
    labs = self.labels
    # Country results to include
    results_cols = [&#39;statistic&#39;] + self.labels.country_level_labels
    included_columns = [col for col in results_cols if col in country_results_cols]
    country_results = country_results[included_columns]
    country_results = country_results.loc[:, ~country_results.columns.duplicated()]

    bilateral_results = self.bilateral_trade_results.reset_index()

    if country_names is not None:
        if country_names.shape[1]!=2:
            raise ValueError(&#34;country_names should have exactly 2 columns, not {}&#34;.format(country_names.shape[1]))
        code_col = country_names.columns[0]
        name_col = country_names.columns[1]
        country_names.set_index(code_col, inplace = True, drop = True)
        country_results = country_names.merge(country_results, how = &#39;right&#39;, left_index = True, right_index=True)

        # Add names to bilateral data
        for side in [exporter_col, importer_col]:
            side_names = country_names.copy()
            side_names.reset_index(inplace = True)
            side_names.rename(columns = {code_col:side, name_col:&#34;{} {}&#34;.format(side,name_col)}, inplace = True)
            bilateral_results = bilateral_results.merge(side_names, how = &#39;left&#39;, on = side)

    # Create Dataframe with Diagnostic results
    column_list = list()
    diagnostics = self.solver_diagnostics
    for trial_num, trial in diagnostics.items():
        for results_type, results in trial.items():
            for key, value in results.items():
                # Single Entry fields must be converted to list before creating DataFrame
                if key in [&#39;success&#39;, &#39;status&#39;, &#39;nfev&#39;, &#39;message&#39;]:
                    frame = pd.DataFrame({(&#34;trial_{}&#34;.format(trial_num), results_type, key): [value]})
                    column_list.append(frame)
                # Vector-like fields Can be used as is. Several available fields are not included: &#39;fjac&#39;,&#39;r&#39;, and &#39;qtf&#39;
                elif key in [&#39;x&#39;, &#39;fun&#39;]:
                    frame = pd.DataFrame({(&#34;trial_{}&#34;.format(trial_num), results_type, key): value})
                    column_list.append(frame)
    diag_frame = pd.concat(column_list, axis=1)
    diag_frame = diag_frame.fillna(&#39;&#39;)

    if directory is not None:
        country_results.to_csv(&#34;{}/{}_country_results.csv&#34;.format(directory, name))
        bilateral_results.to_csv(&#34;{}/{}_bilateral_results.csv&#34;.format(directory, name), index=False)
        diag_frame.to_csv(&#34;{}/{}_solver_diagnostics.csv&#34;.format(directory, name), index=False)
    else:
        return country_results, bilateral_results, diag_frame</code></pre>
</details>
</dd>
<dt id="gegravity.MonteCarloGE.MonteCarloGE.run_trials"><code class="name flex">
<span>def <span class="ident">run_trials</span></span>(<span>self, experiment_data: pandas.core.frame.DataFrame, omr_rescale: float = 1, imr_rescale: float = 1, mr_method: str = 'hybr', mr_max_iter: int = 1400, mr_tolerance: float = 1e-08, ge_method: str = 'hybr', ge_tolerance: float = 1e-08, ge_max_iter: int = 1000, quiet: bool = False, result_stats: list = ['mean', 'std', 'sem'], all_results: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Conduct Monte Carlo Simulation of OneSectorGE gravity model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment_data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>A dataframe containing the counterfactual trade-cost data to use for the
experiment. The best approach for creating this data is to copy the baseline data
(MonteCarloGE.baseline_data.copy()) and modify columns/rows to reflect desired counterfactual experiment.</dd>
<dt><strong><code>omr_rescale</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional) This value rescales the OMR values to assist in convergence. Often, OMR values
are orders of magnitude different than IMR values, which can make convergence difficult. Scaling by a
different order of magnitude can help. Values should be of the form 10^n. By default, this value is 1
(10^0). However, users should be careful with this choice as results, even when convergent, may not be
fully robust to any selection. The method OneSectorGE.check_omr_rescale() can help identify and compare
feasible values for a given model.</dd>
<dt><strong><code>imr_rescale</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional) This value rescales the IMR values to potentially aid in conversion. However,
because the IMR for the reference importer is normalized to one, it is unlikely that there will be because
because changing the default value, which is 1.</dd>
<dt><strong><code>mr_method</code></strong> :&ensp;<code>str</code></dt>
<dd>This parameter determines the type of non-linear solver used for solving the baseline and
experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
value is 'hybr'. (See also OneSectorGE.build_baseline())</dd>
<dt><strong><code>mr_max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>This parameter sets the maximum limit on the number of iterations conducted
by the solver used to solve for MR terms. The default value is 1400.
(See also OneSectorGE.build_baseline())</dd>
<dt><strong><code>mr_tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>This parameter sets the convergence tolerance level for the solver used to
solve for MR terms. The default value is 1e-8. (See also OneSectorGE.build_baseline())</dd>
<dt><strong><code>ge_method</code></strong> :&ensp;<code>str</code></dt>
<dd>The solver method to use for the full GE non-linear solver. See scipy.root()
documentation for option. Default is 'hybr'.</dd>
<dt><strong><code>ge_tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>The tolerance for determining if the GE system of equations is solved.
Default is 1e-8.</dd>
<dt><strong><code>ge_max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of iterations allowed for the full GE nonlinear solver.
Default is 1000.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, suppress console printouts detailing the solver success/failures of each trial.
Default is False.</dd>
<dt><strong><code>result_stats</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of functions to compute in order to summarize the results across trials. The
default is ['mean', 'std', 'sem'], which computes the mean, standard deviation, and standard mean error
of the results, respectively. The model should accept any function that can be used with the
pandas.DataFrame.agg() function.</dd>
<dt><strong><code>all_results</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, MonteCarloGE attributes containing individual results for all trials are
populated. Default is False to reduce memory use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>No return but populates many results attributes of the MonteCarloGE model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_trials(self,
               experiment_data:pd.DataFrame,
               omr_rescale: float = 1,
               imr_rescale: float = 1,
               mr_method: str = &#39;hybr&#39;,
               mr_max_iter: int = 1400,
               mr_tolerance: float = 1e-8,
               ge_method:str = &#39;hybr&#39;,
               ge_tolerance: float = 1e-8,
               ge_max_iter: int = 1000,
               quiet: bool = False,
               result_stats:list = [&#39;mean&#39;, &#39;std&#39;, &#39;sem&#39;],
               all_results:bool = False):
    &#39;&#39;&#39;
    Conduct Monte Carlo Simulation of OneSectorGE gravity model.
    Args:
        experiment_data (pandas.DataFrame): A dataframe containing the counterfactual trade-cost data to use for the
            experiment. The best approach for creating this data is to copy the baseline data
            (MonteCarloGE.baseline_data.copy()) and modify columns/rows to reflect desired counterfactual experiment.
        omr_rescale (int): (optional) This value rescales the OMR values to assist in convergence. Often, OMR values
            are orders of magnitude different than IMR values, which can make convergence difficult. Scaling by a
            different order of magnitude can help. Values should be of the form 10^n. By default, this value is 1
            (10^0). However, users should be careful with this choice as results, even when convergent, may not be
            fully robust to any selection. The method OneSectorGE.check_omr_rescale() can help identify and compare
            feasible values for a given model.
        imr_rescale (int): (optional) This value rescales the IMR values to potentially aid in conversion. However,
            because the IMR for the reference importer is normalized to one, it is unlikely that there will be because
            because changing the default value, which is 1.
        mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
            experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
            value is &#39;hybr&#39;. (See also OneSectorGE.build_baseline())
        mr_max_iter (int): This parameter sets the maximum limit on the number of iterations conducted
            by the solver used to solve for MR terms. The default value is 1400.
            (See also OneSectorGE.build_baseline())
        mr_tolerance (float): This parameter sets the convergence tolerance level for the solver used to
            solve for MR terms. The default value is 1e-8. (See also OneSectorGE.build_baseline())
        ge_method (str): The solver method to use for the full GE non-linear solver. See scipy.root()
            documentation for option. Default is &#39;hybr&#39;.
        ge_tolerance (float): The tolerance for determining if the GE system of equations is solved.
            Default is 1e-8.
        ge_max_iter (int): The maximum number of iterations allowed for the full GE nonlinear solver.
            Default is 1000.
        quiet (bool): If True, suppress console printouts detailing the solver success/failures of each trial.
            Default is False.
        result_stats (list): A list of functions to compute in order to summarize the results across trials. The
            default is [&#39;mean&#39;, &#39;std&#39;, &#39;sem&#39;], which computes the mean, standard deviation, and standard mean error
            of the results, respectively. The model should accept any function that can be used with the
            pandas.DataFrame.agg() function.
        all_results (bool): If true, MonteCarloGE attributes containing individual results for all trials are
            populated. Default is False to reduce memory use.

    Returns:
        None: No return but populates many results attributes of the MonteCarloGE model.

    &#39;&#39;&#39;
    models = list()
    num_failed_iterations = 0
    for trial in range(self.trials):
        print(&#34;\n* Simulating trial {} *&#34;.format(trial))
        param_values = CostCoeffs(self.coeff_sample, coeff_col=trial, identifier_col=&#39;index&#39;)
        try:
            trial_model = OneSectorGE(self._estimation_model,
                                      year=self._year,
                                      reference_importer=self._reference_importer,
                                      expend_var_name=self.meta_data.expend_var_name,
                                      output_var_name=self.meta_data.output_var_name,
                                      sigma=self.sigma,
                                      results_key=self._results_key,
                                      cost_variables=self._cost_variables,
                                      cost_coeff_values=param_values,
                                      # approach = approach,
                                      quiet = quiet)
            trial_model.build_baseline(omr_rescale=omr_rescale,
                                       imr_rescale=imr_rescale,
                                       mr_method=mr_method,
                                       mr_max_iter=mr_max_iter,
                                       mr_tolerance=mr_tolerance)
            trial_model.define_experiment(experiment_data)
            trial_model.simulate(ge_method=ge_method,
                                 ge_tolerance=ge_tolerance,
                                 ge_max_iter=ge_max_iter)
            models.append(trial_model)
        except:
            print(&#34;Failed to solve model.\n&#34;)
            num_failed_iterations+=1

    # Get results labels from one of the OneSectorGE gegravity
    self.labels = models[0].labels
    self.num_failed_trials = num_failed_iterations
    self.all_country_results, self.country_results = self._compile_results(models, &#39;country_results&#39;, result_stats, all_results)
    self.all_country_mr_terms, self.country_mr_terms = self._compile_results(models, &#39;mr_terms&#39;, result_stats, all_results)
    self.all_outputs_expenditures, self.outputs_expenditures = self._compile_results(models, &#39;outputs_expenditures&#39;, result_stats, all_results)
    self.all_factory_gate_prices, self.factory_gate_prices = self._compile_results(models, &#39;factory_gate_prices&#39;, result_stats, all_results)
    self.all_aggregate_trade_results, self.aggregate_trade_results = self._compile_results(models, &#39;aggregate_trade_results&#39;, result_stats, all_results)
    self.all_bilateral_trade_results, self.bilateral_trade_results = self._compile_results(models, &#39;bilateral_trade&#39;, result_stats, all_results)
    self.all_bilateral_costs, self.bilateral_costs = self._compile_results(models, &#39;bilateral_costs&#39;, result_stats, all_results)
    self._compile_diagnostics(models)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gegravity" href="index.html">gegravity</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gegravity.MonteCarloGE.MonteCarloGE" href="#gegravity.MonteCarloGE.MonteCarloGE">MonteCarloGE</a></code></h4>
<ul class="">
<li><code><a title="gegravity.MonteCarloGE.MonteCarloGE.export_results" href="#gegravity.MonteCarloGE.MonteCarloGE.export_results">export_results</a></code></li>
<li><code><a title="gegravity.MonteCarloGE.MonteCarloGE.run_trials" href="#gegravity.MonteCarloGE.MonteCarloGE.run_trials">run_trials</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>